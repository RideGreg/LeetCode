# -*- coding: UTF-8 -*-
# Time:  O(n^2)
# Space: O(n)

# 928 contest 107 10/20/2018
# In a network of nodes, each node i is directly connected to another node j if and only if graph[i][j] = 1.
# Some nodes initial are initially infected by malware.  Whenever two nodes are directly connected and at least 
# one of those two nodes is infected by malware, both nodes will be infected by malware.  This spread of malware 
# will continue until no more nodes can be infected in this manner.

# Suppose M(initial) is the final number of nodes infected with malware, after the spread of malware stops.

# We will remove one node from the initial list, completely removing it and any connections from this node to 
# any other node.  Return the node that if removed, would minimize M(initial).  If multiple nodes could be 
# removed to minimize M(initial), return such a node with the smallest index.

import collections


class UnionFind(object):
    def __init__(self, n):
        self.set = range(n)
        self.sz = [1] * n

    def find_set(self, x):
        if self.set[x] != x:
            self.set[x] = self.find_set(self.set[x])  # path compression.
        return self.set[x]

    def union_set(self, x, y):
        x_root, y_root = map(self.find_set, (x, y))
        if x_root == y_root:
            return False
        self.set[min(x_root, y_root)] = max(x_root, y_root)
        self.sz[max(x_root, y_root)] += self.sz[min(x_root, y_root)]
        return True

    # 统计每个连通图所含节点数目
    def size(self, x):
        return self.sz[self.find_set(x)]

# We need to consider components of the graph. A "Disjoint Set Union" (DSU) data structure is ideal for this.
# Please refer to https://leetcode.com/problems/redundant-connection/solution/ for a tutorial on DSU.
#
# Lets consider the components of G: the graph without any nodes from initial.
#
# For every edge uv in the original graph, where u is in initial and v is not, we can count that
# the component at v of G neighbors 1 more infected node.
#
# Finally, for each node u in initial, for each component of G it neighbors, if that component would only be
# infected by u ("uniquely infected"), then the size of that component contributes to the answer for removing u.
class Solution(object):
    def minMalwareSpread(self, graph, initial):
        """
        :type graph: List[List[int]]
        :type initial: List[int]
        :rtype: int
        """
        initial_set = set(initial)

        # 因为去掉脏节点同时改变原图结构，所以只连通所有干净节点
        # 所有干净节点组成的子图中，每个连通图作为一个整体，处理一次即可
        clean = [i for i in xrange(len(graph)) if i not in initial_set]
        union_find = UnionFind(len(graph))
        for i in clean:
            for j in clean:
                if graph[i][j] == 1 and i < j:
                    union_find.union_set(i, j)

        dirty_to_clean = collections.defaultdict(set) #每个脏节点连接的干净连通图，要挨个检查
        clean_to_dirty = collections.Counter() #每个干净连通图连接的脏节点数目
        for i in initial:
            for j in clean:
                if graph[i][j] == 1:
                    x = union_find.find_set(j)
                    dirty_to_clean[i].add(x)
            for x in dirty_to_clean[i]:
                clean_to_dirty[x] += 1

        if not dirty_to_clean: return min(initial)

        ans, total = min(initial), -1
        for i, components in dirty_to_clean.iteritems():
            curr = 0 #去掉当前脏节点i，可save的干净节点数目
            for x in components:
                if clean_to_dirty[x] == 1:
                    curr += union_find.size(x)
            if curr > total or (curr == total and i < ans):
                ans, total = i, curr
        return ans

# DFS algorithm
# Time:  O(n^2)
# Space: O(n)

# Let G be the graph with all the nodes from initial removed.
# For each node v not in initial, we want to know which nodes u from initial can reach v in the graph G
# [with u (and its edges) added to G]. Let's say these nodes u "infect" v.
# Afterwards, we want to know which nodes v are uniquely infected by only one u. For each such pair, it contributes 1 to the answer for u.

class Solution2(object):
    def minMalwareSpread(self, graph, initial):
        N = len(graph)
        clean = set(range(N)) - set(initial)
        def dfs(u, seen):
            for v, adj in enumerate(graph[u]):
                if adj and v in clean and v not in seen:
                    seen.add(v)
                    dfs(v, seen)

        # For each node u in initial, dfs to find
        # 'seen': all nodes not in initial that it can reach.
        infected_by = {v: [] for v in clean}
        for u in initial:
            seen = set()
            dfs(u, seen)

            # For each node v that was seen, u infects v.
            for v in seen:
                infected_by[v].append(u)

        # For each node u in initial, for every v not in initial
        # that is uniquely infected by u, add 1 to the contribution for u.
        contribution = collections.Counter()
        for v, neighbors in infected_by.iteritems():
            if len(neighbors) == 1:
                contribution[neighbors[0]] += 1

        # Take the best answer.
        best = (-1, min(initial))
        for u, score in contribution.iteritems():
            if score > best[0] or score == best[0] and u < best[1]:
                best = score, u
        return best[1]

print(Solution().minMalwareSpread([[1,1,0],[1,1,0],[0,0,1]], [0,1])) # 0
print(Solution().minMalwareSpread([[1,1,0],[1,1,1],[0,1,1]], [0,1])) # 1
print(Solution().minMalwareSpread([[1,1,0,0],[1,1,1,0],[0,1,1,1],[0,0,1,1]], [0,1])) # 1