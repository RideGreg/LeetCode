# -*- coding: UTF-8 -*-
# Time:  O(n^2), n is the size of graph
# Space: O(n)

# 928 contest 107 10/20/2018
# In a network of nodes, each node i is directly connected to another node j if and only if graph[i][j] = 1.
# Some nodes initial are initially infected by malware.  Whenever two nodes are directly connected and at least 
# one of those two nodes is infected by malware, both nodes will be infected by malware.  This spread of malware 
# will continue until no more nodes can be infected in this manner.

# Suppose M(initial) is the final number of nodes infected with malware, after the spread of malware stops.

# We will remove one node from the initial list, completely removing it and any connections from this node to 
# any other node.  Return the node that if removed, would minimize M(initial).  If multiple nodes could be 
# removed to minimize M(initial), return such a node with the smallest index.

import collections


class UnionFind(object):
    def __init__(self, n):
        self.set = list(range(n))
        self.sz = [1] * n

    def find_set(self, x):
        if self.set[x] != x:
            self.set[x] = self.find_set(self.set[x])  # path compression.
        return self.set[x]

    def union_set(self, x, y):
        x_root, y_root = map(self.find_set, (x, y))
        if x_root == y_root:
            return False
        self.set[min(x_root, y_root)] = max(x_root, y_root)
        self.sz[max(x_root, y_root)] += self.sz[min(x_root, y_root)]
        return True

    # 统计每个连通图所含节点数目
    def size(self, x):
        return self.sz[self.find_set(x)]

# We need to consider components of the graph. A "Disjoint Set Union" (DSU) data structure is ideal for this.
# Please refer to https://leetcode.com/problems/redundant-connection/solution/ for a tutorial on DSU.
#
# Since removing an infected node and its connection only affects clean nodes, we build union-find on all
# clean nodes (components of G: the graph without any nodes from initial).
#
# A double loop (on infected nodes and on clean nodes): 1. get what clean components connected to each
# infected node; 2. how many infected nodes connecting to each clean component.
#
# Finally, for each infected node connecting to clean components, count how many clean nodes it affects, but only
# add the clean components which is uniquely infected by this infected node.
class Solution(object):
    def minMalwareSpread(self, graph, initial): # USE THIS
        """
        :type graph: List[List[int]]
        :type initial: List[int]
        :rtype: int
        """
        initial_set = set(initial)

        # build union-find on clean nodes only
        # 因为去掉脏节点同时改变原图结构，所以只连通所有干净节点
        # 所有干净节点组成的子图中，每个连通图作为一个整体，处理一次即可
        clean = [i for i in range(len(graph)) if i not in initial_set]
        uf = UnionFind(len(graph))  #坑，注意！should build UnionFind using original len not length of clean.
        for i in clean:
            for j in clean:
                if graph[i][j] == 1 and i < j:
                    uf.union_set(i, j)

        dirty2cleanRoot = collections.defaultdict(set) #每个脏节点连接的干净连通图，要挨个检查
        cleanRoot2dirty = collections.Counter() #每个干净连通图连接的脏节点数目
        for i in initial:
            for j in clean:
                if graph[i][j] == 1:
                    x = uf.find_set(j)
                    dirty2cleanRoot[i].add(x) #坑，注意！在set中必须储存连通图root，不能只存j，因为j可能连着其它干净节点
            for x in dirty2cleanRoot[i]:
                cleanRoot2dirty[x] += 1

        if not dirty2cleanRoot: return min(initial)

        ans, score = min(initial), -1
        for i in sorted(initial):
            curr = 0                 #去掉当前脏节点i，可save的干净节点数目
            for x in dirty2cleanRoot[i]:
                if cleanRoot2dirty[x] == 1:
                    curr += uf.size(x)
            if curr > score:
                ans, score = i, curr
        return ans


# DFS algorithm
# Time:  O(n^2)
# Space: O(n)

# Let G be the graph with all the nodes from initial removed.
# For each node v not in initial, we want to know which nodes u from initial can reach v in the graph G
# [with u (and its edges) added to G]. Let's say these nodes u "infect" v.
# Afterwards, we want to know which nodes v are uniquely infected by only one u. For each such pair, it contributes 1 to the answer for u.

class Solution2(object):
    def minMalwareSpread(self, graph, initial):
        N = len(graph)
        clean = set(range(N)) - set(initial)
        def dfs(u, seen):
            for v, adj in enumerate(graph[u]):
                if adj and v in clean and v not in seen:
                    seen.add(v)
                    dfs(v, seen)

        # For each node u in initial, dfs to find
        # 'seen': all nodes not in initial that it can reach.
        infected_by = {v: [] for v in clean}
        for u in initial:
            seen = set()
            dfs(u, seen)

            # For each node v that was seen, u infects v.
            for v in seen:
                infected_by[v].append(u)

        # For each node u in initial, for every v not in initial
        # that is uniquely infected by u, add 1 to the contribution for u.
        contribution = collections.Counter()
        for v, neighbors in infected_by.iteritems():
            if len(neighbors) == 1:
                contribution[neighbors[0]] += 1

        # Take the best answer.
        best = (-1, min(initial))
        for u, score in contribution.iteritems():
            if score > best[0] or score == best[0] and u < best[1]:
                best = score, u
        return best[1]


print(Solution().minMalwareSpread([[1,1,0,0,0,0,0,0,0,0],
                                   [1,1,0,0,0,0,0,0,0,0],
                                   [0,0,1,0,0,0,0,0,0,0],
                                   [0,0,0,1,0,0,1,0,0,1],
                                   [0,0,0,0,1,0,0,0,0,0],
                                   [0,0,0,0,0,1,0,0,0,0],
                                   [0,0,0,1,0,0,1,0,0,0],
                                   [0,0,0,0,0,0,0,1,0,0],
                                   [0,0,0,0,0,0,0,0,1,0],
                                   [0,0,0,1,0,0,0,0,0,1]],
                                  [2,1,9])) # 9
print(Solution().minMalwareSpread([[1,1,0],[1,1,0],[0,0,1]], [0,1])) # 0
print(Solution().minMalwareSpread([[1,1,0],[1,1,1],[0,1,1]], [0,1])) # 1
print(Solution().minMalwareSpread([[1,1,0,0],[1,1,1,0],[0,1,1,1],[0,0,1,1]], [0,1])) # 1

print(Solution().minMalwareSpread([
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,1,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0],
    [0,0,0,0,1,0,0,0,1,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0],
    [0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [0,0,0,0,1,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0],
    [0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0],
    [0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,1,0,0,1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,1,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [0,0,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,1,0,0,0],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,1,0,0],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,1,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0],
    [0,0,0,1,0,1,0,0,1,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1,1,0,0,0],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,1,0,0],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0],
    [0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1]],
[1,6,35,5,27,32]
)) # 32
